// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"
)

const createEvent = `-- name: CreateEvent :execresult
INSERT INTO Event (
    Name, Date
)
VALUES (
    ?, ?
)
`

type CreateEventParams struct {
	Name string    `json:"name"`
	Date time.Time `json:"date"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEvent, arg.Name, arg.Date)
}

const createMember = `-- name: CreateMember :execresult
INSERT INTO Member (
    ArcheryAustraliaID, PasswordHash, FirstName, DateOfBirth, Gender, ClubRecorder
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateMemberParams struct {
	Archeryaustraliaid string       `json:"archeryaustraliaid"`
	Passwordhash       string       `json:"passwordhash"`
	Firstname          string       `json:"firstname"`
	Dateofbirth        time.Time    `json:"dateofbirth"`
	Gender             MemberGender `json:"gender"`
	Clubrecorder       bool         `json:"clubrecorder"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMember,
		arg.Archeryaustraliaid,
		arg.Passwordhash,
		arg.Firstname,
		arg.Dateofbirth,
		arg.Gender,
		arg.Clubrecorder,
	)
}

const createRound = `-- name: CreateRound :execresult
INSERT INTO ` + "`" + `Round` + "`" + ` (
    EventID, Division, Class, Gender
)
VALUES (
    ?, ?, ?, ?
)
`

type CreateRoundParams struct {
	Eventid  int32             `json:"eventid"`
	Division NullRoundDivision `json:"division"`
	Class    RoundClass        `json:"class"`
	Gender   RoundGender       `json:"gender"`
}

func (q *Queries) CreateRound(ctx context.Context, arg CreateRoundParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createRound,
		arg.Eventid,
		arg.Division,
		arg.Class,
		arg.Gender,
	)
}

const deleteMember = `-- name: DeleteMember :exec
DELETE FROM Member
WHERE ArcheryAustraliaID = ?
`

func (q *Queries) DeleteMember(ctx context.Context, archeryaustraliaid string) error {
	_, err := q.db.ExecContext(ctx, deleteMember, archeryaustraliaid)
	return err
}

const getEndsByID = `-- name: GetEndsByID :many
SELECT endid, en.rangeid, archeryaustraliaid, finalscore, staged, ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date
FROM End en
JOIN ` + "`" + `Range` + "`" + ` ra ON ra.RangeID = en.RangeID
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ? AND en.RangeID = ?
LIMIT ?
OFFSET ?
`

type GetEndsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Rangeid            int32  `json:"rangeid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetEndsByIDRow struct {
	Endid              int32             `json:"endid"`
	Rangeid            int32             `json:"rangeid"`
	Archeryaustraliaid string            `json:"archeryaustraliaid"`
	Finalscore         int32             `json:"finalscore"`
	Staged             bool              `json:"staged"`
	Rangeid_2          int32             `json:"rangeid_2"`
	Roundid            int32             `json:"roundid"`
	Distance           int32             `json:"distance"`
	Targetsize         int32             `json:"targetsize"`
	Roundid_2          int32             `json:"roundid_2"`
	Eventid            int32             `json:"eventid"`
	Class              RoundClass        `json:"class"`
	Division           NullRoundDivision `json:"division"`
	Gender             RoundGender       `json:"gender"`
	Eventid_2          int32             `json:"eventid_2"`
	Name               string            `json:"name"`
	Date               time.Time         `json:"date"`
}

func (q *Queries) GetEndsByID(ctx context.Context, arg GetEndsByIDParams) ([]GetEndsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEndsByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Rangeid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEndsByIDRow
	for rows.Next() {
		var i GetEndsByIDRow
		if err := rows.Scan(
			&i.Endid,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
			&i.Rangeid_2,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvents = `-- name: GetEvents :many
SELECT eventid, name, date
FROM Event
LIMIT ?
OFFSET ?
`

type GetEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(&i.Eventid, &i.Name, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByID = `-- name: GetEventsByID :many
SELECT e.eventid, name, date, r.roundid, r.eventid, class, division, gender, ra.rangeid, ra.roundid, distance, targetsize, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM Event e
JOIN ` + "`" + `Round` + "`" + ` r ON e.EventID = r.EventID
JOIN ` + "`" + `Range` + "`" + ` ra ON r.RoundID = ra.RoundID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ?
LIMIT ?
OFFSET ?
`

type GetEventsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetEventsByIDRow struct {
	Eventid            int32             `json:"eventid"`
	Name               string            `json:"name"`
	Date               time.Time         `json:"date"`
	Roundid            int32             `json:"roundid"`
	Eventid_2          int32             `json:"eventid_2"`
	Class              RoundClass        `json:"class"`
	Division           NullRoundDivision `json:"division"`
	Gender             RoundGender       `json:"gender"`
	Rangeid            int32             `json:"rangeid"`
	Roundid_2          int32             `json:"roundid_2"`
	Distance           int32             `json:"distance"`
	Targetsize         int32             `json:"targetsize"`
	Endid              int32             `json:"endid"`
	Rangeid_2          int32             `json:"rangeid_2"`
	Archeryaustraliaid string            `json:"archeryaustraliaid"`
	Finalscore         int32             `json:"finalscore"`
	Staged             bool              `json:"staged"`
}

func (q *Queries) GetEventsByID(ctx context.Context, arg GetEventsByIDParams) ([]GetEventsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByID, arg.Archeryaustraliaid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByIDRow
	for rows.Next() {
		var i GetEventsByIDRow
		if err := rows.Scan(
			&i.Eventid,
			&i.Name,
			&i.Date,
			&i.Roundid,
			&i.Eventid_2,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Rangeid,
			&i.Roundid_2,
			&i.Distance,
			&i.Targetsize,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberByID = `-- name: GetMemberByID :one
SELECT archeryaustraliaid, passwordhash, firstname, dateofbirth, gender, clubrecorder FROM Member
WHERE ArcheryAustraliaID = ?
LIMIT 1
`

func (q *Queries) GetMemberByID(ctx context.Context, archeryaustraliaid string) (Member, error) {
	row := q.db.QueryRowContext(ctx, getMemberByID, archeryaustraliaid)
	var i Member
	err := row.Scan(
		&i.Archeryaustraliaid,
		&i.Passwordhash,
		&i.Firstname,
		&i.Dateofbirth,
		&i.Gender,
		&i.Clubrecorder,
	)
	return i, err
}

const getPracticeEventsByID = `-- name: GetPracticeEventsByID :many
SELECT e.eventid, e.name, e.date
FROM Event e
JOIN PracticeEvent pe ON e.EventID = pe.EventID
WHERE pe.ArcheryAustraliaID = ?
LIMIT ?
OFFSET ?
`

type GetPracticeEventsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

func (q *Queries) GetPracticeEventsByID(ctx context.Context, arg GetPracticeEventsByIDParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getPracticeEventsByID, arg.Archeryaustraliaid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(&i.Eventid, &i.Name, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRangesByID = `-- name: GetRangesByID :many
SELECT ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM ` + "`" + `Range` + "`" + ` ra
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ?
LIMIT ?
OFFSET ?
`

type GetRangesByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetRangesByIDRow struct {
	Rangeid            int32             `json:"rangeid"`
	Roundid            int32             `json:"roundid"`
	Distance           int32             `json:"distance"`
	Targetsize         int32             `json:"targetsize"`
	Roundid_2          int32             `json:"roundid_2"`
	Eventid            int32             `json:"eventid"`
	Class              RoundClass        `json:"class"`
	Division           NullRoundDivision `json:"division"`
	Gender             RoundGender       `json:"gender"`
	Eventid_2          int32             `json:"eventid_2"`
	Name               string            `json:"name"`
	Date               time.Time         `json:"date"`
	Endid              int32             `json:"endid"`
	Rangeid_2          int32             `json:"rangeid_2"`
	Archeryaustraliaid string            `json:"archeryaustraliaid"`
	Finalscore         int32             `json:"finalscore"`
	Staged             bool              `json:"staged"`
}

func (q *Queries) GetRangesByID(ctx context.Context, arg GetRangesByIDParams) ([]GetRangesByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRangesByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRangesByIDRow
	for rows.Next() {
		var i GetRangesByIDRow
		if err := rows.Scan(
			&i.Rangeid,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRounds = `-- name: GetRounds :many
SELECT eventid, name, date
FROM Event
LIMIT ?
OFFSET ?
`

type GetRoundsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetRounds(ctx context.Context, arg GetRoundsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getRounds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(&i.Eventid, &i.Name, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundsByID = `-- name: GetRoundsByID :many
SELECT r.roundid, r.eventid, class, division, gender, e.eventid, name, date, ra.rangeid, ra.roundid, distance, targetsize, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM ` + "`" + `Round` + "`" + ` r
JOIN Event e ON e.EventID = r.EventID
JOIN ` + "`" + `Range` + "`" + ` ra ON r.RoundID = ra.RoundID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ?
LIMIT ?
OFFSET ?
`

type GetRoundsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetRoundsByIDRow struct {
	Roundid            int32             `json:"roundid"`
	Eventid            int32             `json:"eventid"`
	Class              RoundClass        `json:"class"`
	Division           NullRoundDivision `json:"division"`
	Gender             RoundGender       `json:"gender"`
	Eventid_2          int32             `json:"eventid_2"`
	Name               string            `json:"name"`
	Date               time.Time         `json:"date"`
	Rangeid            int32             `json:"rangeid"`
	Roundid_2          int32             `json:"roundid_2"`
	Distance           int32             `json:"distance"`
	Targetsize         int32             `json:"targetsize"`
	Endid              int32             `json:"endid"`
	Rangeid_2          int32             `json:"rangeid_2"`
	Archeryaustraliaid string            `json:"archeryaustraliaid"`
	Finalscore         int32             `json:"finalscore"`
	Staged             bool              `json:"staged"`
}

func (q *Queries) GetRoundsByID(ctx context.Context, arg GetRoundsByIDParams) ([]GetRoundsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundsByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundsByIDRow
	for rows.Next() {
		var i GetRoundsByIDRow
		if err := rows.Scan(
			&i.Roundid,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
			&i.Rangeid,
			&i.Roundid_2,
			&i.Distance,
			&i.Targetsize,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoresByID = `-- name: GetScoresByID :many
SELECT scoreid, s.endid, arrownumber, score, en.endid, en.rangeid, archeryaustraliaid, finalscore, staged, ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date
FROM Score s
JOIN End en ON s.EndID = en.EndID
JOIN ` + "`" + `Range` + "`" + ` ra ON ra.RangeID = en.RangeID
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ? AND en.RangeID = ? AND en.EndID = ?
LIMIT ?
OFFSET ?
`

type GetScoresByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Rangeid            int32  `json:"rangeid"`
	Endid              int32  `json:"endid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetScoresByIDRow struct {
	Scoreid            int32             `json:"scoreid"`
	Endid              int32             `json:"endid"`
	Arrownumber        int32             `json:"arrownumber"`
	Score              string            `json:"score"`
	Endid_2            int32             `json:"endid_2"`
	Rangeid            int32             `json:"rangeid"`
	Archeryaustraliaid string            `json:"archeryaustraliaid"`
	Finalscore         int32             `json:"finalscore"`
	Staged             bool              `json:"staged"`
	Rangeid_2          int32             `json:"rangeid_2"`
	Roundid            int32             `json:"roundid"`
	Distance           int32             `json:"distance"`
	Targetsize         int32             `json:"targetsize"`
	Roundid_2          int32             `json:"roundid_2"`
	Eventid            int32             `json:"eventid"`
	Class              RoundClass        `json:"class"`
	Division           NullRoundDivision `json:"division"`
	Gender             RoundGender       `json:"gender"`
	Eventid_2          int32             `json:"eventid_2"`
	Name               string            `json:"name"`
	Date               time.Time         `json:"date"`
}

func (q *Queries) GetScoresByID(ctx context.Context, arg GetScoresByIDParams) ([]GetScoresByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getScoresByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Rangeid,
		arg.Endid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresByIDRow
	for rows.Next() {
		var i GetScoresByIDRow
		if err := rows.Scan(
			&i.Scoreid,
			&i.Endid,
			&i.Arrownumber,
			&i.Score,
			&i.Endid_2,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
			&i.Rangeid_2,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
