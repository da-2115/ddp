// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package data

import (
	"context"
	"database/sql"
	"time"
)

const createEnd = `-- name: CreateEnd :execresult
INSERT INTO End (
    RangeID, ArcheryAustraliaID, FinalScore, Staged
)
VALUES (
    ?, ?, ?, TRUE
)
`

type CreateEndParams struct {
	Rangeid            int32  `json:"rangeid"`
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Finalscore         int32  `json:"finalscore"`
}

func (q *Queries) CreateEnd(ctx context.Context, arg CreateEndParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEnd, arg.Rangeid, arg.Archeryaustraliaid, arg.Finalscore)
}

const createEvent = `-- name: CreateEvent :execresult
INSERT INTO Event (
    Name, Date
)
VALUES (
    ?, ?
)
`

type CreateEventParams struct {
	Name string    `json:"name"`
	Date time.Time `json:"date"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createEvent, arg.Name, arg.Date)
}

const createMember = `-- name: CreateMember :execresult
INSERT INTO Member (
    ArcheryAustraliaID, PasswordHash, FirstName, DateOfBirth, Gender, ClubRecorder
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateMemberParams struct {
	Archeryaustraliaid string       `json:"archeryaustraliaid"`
	Passwordhash       string       `json:"passwordhash"`
	Firstname          string       `json:"firstname"`
	Dateofbirth        time.Time    `json:"dateofbirth"`
	Gender             MemberGender `json:"gender"`
	Clubrecorder       bool         `json:"clubrecorder"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMember,
		arg.Archeryaustraliaid,
		arg.Passwordhash,
		arg.Firstname,
		arg.Dateofbirth,
		arg.Gender,
		arg.Clubrecorder,
	)
}

const createRound = `-- name: CreateRound :execresult
INSERT INTO ` + "`" + `Round` + "`" + ` (
    EventID, Division, Class, Gender
)
VALUES (
    ?, ?, ?, ?
)
`

type CreateRoundParams struct {
	Eventid  int32         `json:"eventid"`
	Division RoundDivision `json:"division"`
	Class    RoundClass    `json:"class"`
	Gender   RoundGender   `json:"gender"`
}

func (q *Queries) CreateRound(ctx context.Context, arg CreateRoundParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createRound,
		arg.Eventid,
		arg.Division,
		arg.Class,
		arg.Gender,
	)
}

const createScore = `-- name: CreateScore :execresult
INSERT INTO Score (
    EndID, ArrowNumber, Score
)
VALUES (
    ?, ?, ?
)
`

type CreateScoreParams struct {
	Endid       int32  `json:"endid"`
	Arrownumber int32  `json:"arrownumber"`
	Score       string `json:"score"`
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createScore, arg.Endid, arg.Arrownumber, arg.Score)
}

const deleteEnd = `-- name: DeleteEnd :exec
DELETE FROM End
WHERE EndID = ?
`

func (q *Queries) DeleteEnd(ctx context.Context, endid int32) error {
	_, err := q.db.ExecContext(ctx, deleteEnd, endid)
	return err
}

const deleteMember = `-- name: DeleteMember :exec
DELETE FROM Member
WHERE ArcheryAustraliaID = ?
`

func (q *Queries) DeleteMember(ctx context.Context, archeryaustraliaid string) error {
	_, err := q.db.ExecContext(ctx, deleteMember, archeryaustraliaid)
	return err
}

const getAllEvents = `-- name: GetAllEvents :many
SELECT eventid, name, date
FROM Event
LIMIT ?
OFFSET ?
`

type GetAllEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllEvents(ctx context.Context, arg GetAllEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getAllEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(&i.Eventid, &i.Name, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEndByRound = `-- name: GetEndByRound :many
SELECT endid, rangeid, archeryaustraliaid, finalscore, staged
FROM End
WHERE RangeID = ?
LIMIT ?
OFFSET ?
`

type GetEndByRoundParams struct {
	Rangeid int32 `json:"rangeid"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetEndByRound(ctx context.Context, arg GetEndByRoundParams) ([]End, error) {
	rows, err := q.db.QueryContext(ctx, getEndByRound, arg.Rangeid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []End
	for rows.Next() {
		var i End
		if err := rows.Scan(
			&i.Endid,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEndsByID = `-- name: GetEndsByID :many
SELECT endid, en.rangeid, archeryaustraliaid, finalscore, staged, ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date
FROM End en
JOIN ` + "`" + `Range` + "`" + ` ra ON ra.RangeID = en.RangeID
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ? AND en.RangeID = ?
GROUP BY en.EndID
LIMIT ?
OFFSET ?
`

type GetEndsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Rangeid            int32  `json:"rangeid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetEndsByIDRow struct {
	Endid              int32         `json:"endid"`
	Rangeid            int32         `json:"rangeid"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Roundid            int32         `json:"roundid"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Roundid_2          int32         `json:"roundid_2"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Eventid_2          int32         `json:"eventid_2"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
}

func (q *Queries) GetEndsByID(ctx context.Context, arg GetEndsByIDParams) ([]GetEndsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEndsByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Rangeid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEndsByIDRow
	for rows.Next() {
		var i GetEndsByIDRow
		if err := rows.Scan(
			&i.Endid,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
			&i.Rangeid_2,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByID = `-- name: GetEventsByID :many
SELECT e.eventid, name, date, r.roundid, r.eventid, class, division, gender, ra.rangeid, ra.roundid, distance, targetsize, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM Event e
JOIN ` + "`" + `Round` + "`" + ` r ON e.EventID = r.EventID
JOIN ` + "`" + `Range` + "`" + ` ra ON r.RoundID = ra.RoundID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ?
GROUP BY e.EventID
LIMIT ?
OFFSET ?
`

type GetEventsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetEventsByIDRow struct {
	Eventid            int32         `json:"eventid"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
	Roundid            int32         `json:"roundid"`
	Eventid_2          int32         `json:"eventid_2"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Rangeid            int32         `json:"rangeid"`
	Roundid_2          int32         `json:"roundid_2"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Endid              int32         `json:"endid"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
}

func (q *Queries) GetEventsByID(ctx context.Context, arg GetEventsByIDParams) ([]GetEventsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByID, arg.Archeryaustraliaid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsByIDRow
	for rows.Next() {
		var i GetEventsByIDRow
		if err := rows.Scan(
			&i.Eventid,
			&i.Name,
			&i.Date,
			&i.Roundid,
			&i.Eventid_2,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Rangeid,
			&i.Roundid_2,
			&i.Distance,
			&i.Targetsize,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemberByID = `-- name: GetMemberByID :one
SELECT archeryaustraliaid, passwordhash, firstname, dateofbirth, gender, clubrecorder FROM Member
WHERE ArcheryAustraliaID = ?
LIMIT 1
`

func (q *Queries) GetMemberByID(ctx context.Context, archeryaustraliaid string) (Member, error) {
	row := q.db.QueryRowContext(ctx, getMemberByID, archeryaustraliaid)
	var i Member
	err := row.Scan(
		&i.Archeryaustraliaid,
		&i.Passwordhash,
		&i.Firstname,
		&i.Dateofbirth,
		&i.Gender,
		&i.Clubrecorder,
	)
	return i, err
}

const getPracticeEventsByID = `-- name: GetPracticeEventsByID :many
SELECT e.eventid, name, date, practiceid, pe.eventid, archeryaustraliaid
FROM Event e
JOIN PracticeEvent pe ON e.EventID = pe.EventID
WHERE pe.ArcheryAustraliaID = ?
GROUP BY e.EventID
LIMIT ?
OFFSET ?
`

type GetPracticeEventsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetPracticeEventsByIDRow struct {
	Eventid            int32     `json:"eventid"`
	Name               string    `json:"name"`
	Date               time.Time `json:"date"`
	Practiceid         int32     `json:"practiceid"`
	Eventid_2          int32     `json:"eventid_2"`
	Archeryaustraliaid string    `json:"archeryaustraliaid"`
}

func (q *Queries) GetPracticeEventsByID(ctx context.Context, arg GetPracticeEventsByIDParams) ([]GetPracticeEventsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPracticeEventsByID, arg.Archeryaustraliaid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPracticeEventsByIDRow
	for rows.Next() {
		var i GetPracticeEventsByIDRow
		if err := rows.Scan(
			&i.Eventid,
			&i.Name,
			&i.Date,
			&i.Practiceid,
			&i.Eventid_2,
			&i.Archeryaustraliaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRangeByRound = `-- name: GetRangeByRound :many
SELECT rangeid, roundid, distance, targetsize
FROM ` + "`" + `Range` + "`" + `
WHERE RoundID = ?
LIMIT ?
OFFSET ?
`

type GetRangeByRoundParams struct {
	Roundid int32 `json:"roundid"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetRangeByRound(ctx context.Context, arg GetRangeByRoundParams) ([]Range, error) {
	rows, err := q.db.QueryContext(ctx, getRangeByRound, arg.Roundid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Range
	for rows.Next() {
		var i Range
		if err := rows.Scan(
			&i.Rangeid,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRangesByID = `-- name: GetRangesByID :many
SELECT ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM ` + "`" + `Range` + "`" + ` ra
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ?
GROUP BY ra.RangeID
LIMIT ?
OFFSET ?
`

type GetRangesByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetRangesByIDRow struct {
	Rangeid            int32         `json:"rangeid"`
	Roundid            int32         `json:"roundid"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Roundid_2          int32         `json:"roundid_2"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Eventid_2          int32         `json:"eventid_2"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
	Endid              int32         `json:"endid"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
}

func (q *Queries) GetRangesByID(ctx context.Context, arg GetRangesByIDParams) ([]GetRangesByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRangesByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRangesByIDRow
	for rows.Next() {
		var i GetRangesByIDRow
		if err := rows.Scan(
			&i.Rangeid,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundByEvent = `-- name: GetRoundByEvent :many
SELECT roundid, eventid, class, division, gender
FROM ` + "`" + `Round` + "`" + `
WHERE EventID = ?
LIMIT ?
OFFSET ?
`

type GetRoundByEventParams struct {
	Eventid int32 `json:"eventid"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetRoundByEvent(ctx context.Context, arg GetRoundByEventParams) ([]Round, error) {
	rows, err := q.db.QueryContext(ctx, getRoundByEvent, arg.Eventid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Round
	for rows.Next() {
		var i Round
		if err := rows.Scan(
			&i.Roundid,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRounds = `-- name: GetRounds :many
SELECT  roundid, eventid, class, division, r.gender, archeryaustraliaid, passwordhash, firstname, dateofbirth, m.gender, clubrecorder
FROM Round r
JOIN Member m ON (
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) <= 14 AND r.Class IN ('Under14', 'Under16', 'Under18', 'Under21', 'Open')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) <= 16 AND r.Class IN ('Under16', 'Under18', 'Under21', 'Open')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) <= 18 AND r.Class IN ('Under18', 'Under21', 'Open')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) <= 21 AND r.Class IN ('Under21', 'Open')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) > 21 AND r.Class IN ('Open')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) >= 50 AND r.Class IN ('Open', '50Plus')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) >= 60 AND r.Class IN ('Open', '50Plus', '60Plus')) OR
        (YEAR(CURDATE()) - YEAR(m.DateOfBirth) >= 70 AND r.Class IN ('Open', '50Plus', '60Plus', '70Plus'))
    )
WHERE m.ArcheryAustraliaID = ? AND r.EventID = ? AND m.Gender = r.Gender
LIMIT ?
OFFSET ?
`

type GetRoundsParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetRoundsRow struct {
	Roundid            int32         `json:"roundid"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Passwordhash       string        `json:"passwordhash"`
	Firstname          string        `json:"firstname"`
	Dateofbirth        time.Time     `json:"dateofbirth"`
	Gender_2           MemberGender  `json:"gender_2"`
	Clubrecorder       bool          `json:"clubrecorder"`
}

func (q *Queries) GetRounds(ctx context.Context, arg GetRoundsParams) ([]GetRoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRounds,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundsRow
	for rows.Next() {
		var i GetRoundsRow
		if err := rows.Scan(
			&i.Roundid,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Archeryaustraliaid,
			&i.Passwordhash,
			&i.Firstname,
			&i.Dateofbirth,
			&i.Gender_2,
			&i.Clubrecorder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundsByID = `-- name: GetRoundsByID :many
SELECT r.roundid, r.eventid, class, division, gender, e.eventid, name, date, ra.rangeid, ra.roundid, distance, targetsize, endid, en.rangeid, archeryaustraliaid, finalscore, staged
FROM ` + "`" + `Round` + "`" + ` r
JOIN Event e ON e.EventID = r.EventID
JOIN ` + "`" + `Range` + "`" + ` ra ON r.RoundID = ra.RoundID
JOIN End en ON ra.RangeID = en.RangeID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ?
GROUP BY r.RoundID
LIMIT ?
OFFSET ?
`

type GetRoundsByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetRoundsByIDRow struct {
	Roundid            int32         `json:"roundid"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Eventid_2          int32         `json:"eventid_2"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
	Rangeid            int32         `json:"rangeid"`
	Roundid_2          int32         `json:"roundid_2"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Endid              int32         `json:"endid"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
}

func (q *Queries) GetRoundsByID(ctx context.Context, arg GetRoundsByIDParams) ([]GetRoundsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoundsByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundsByIDRow
	for rows.Next() {
		var i GetRoundsByIDRow
		if err := rows.Scan(
			&i.Roundid,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
			&i.Rangeid,
			&i.Roundid_2,
			&i.Distance,
			&i.Targetsize,
			&i.Endid,
			&i.Rangeid_2,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoreByEnd = `-- name: GetScoreByEnd :many
SELECT scoreid, endid, arrownumber, score
FROM Score
WHERE EndID = ?
`

func (q *Queries) GetScoreByEnd(ctx context.Context, endid int32) ([]Score, error) {
	rows, err := q.db.QueryContext(ctx, getScoreByEnd, endid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Score
	for rows.Next() {
		var i Score
		if err := rows.Scan(
			&i.Scoreid,
			&i.Endid,
			&i.Arrownumber,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoresByID = `-- name: GetScoresByID :many
SELECT scoreid, s.endid, arrownumber, score, en.endid, en.rangeid, archeryaustraliaid, finalscore, staged, ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date
FROM Score s
JOIN End en ON s.EndID = en.EndID
JOIN ` + "`" + `Range` + "`" + ` ra ON ra.RangeID = en.RangeID
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
WHERE en.ArcheryAustraliaID = ? AND e.EventID = ? AND r.RoundID = ? AND en.RangeID = ? AND en.EndID = ?
GROUP BY s.ScoreID
LIMIT ?
OFFSET ?
`

type GetScoresByIDParams struct {
	Archeryaustraliaid string `json:"archeryaustraliaid"`
	Eventid            int32  `json:"eventid"`
	Roundid            int32  `json:"roundid"`
	Rangeid            int32  `json:"rangeid"`
	Endid              int32  `json:"endid"`
	Limit              int32  `json:"limit"`
	Offset             int32  `json:"offset"`
}

type GetScoresByIDRow struct {
	Scoreid            int32         `json:"scoreid"`
	Endid              int32         `json:"endid"`
	Arrownumber        int32         `json:"arrownumber"`
	Score              string        `json:"score"`
	Endid_2            int32         `json:"endid_2"`
	Rangeid            int32         `json:"rangeid"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Roundid            int32         `json:"roundid"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Roundid_2          int32         `json:"roundid_2"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Eventid_2          int32         `json:"eventid_2"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
}

func (q *Queries) GetScoresByID(ctx context.Context, arg GetScoresByIDParams) ([]GetScoresByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getScoresByID,
		arg.Archeryaustraliaid,
		arg.Eventid,
		arg.Roundid,
		arg.Rangeid,
		arg.Endid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoresByIDRow
	for rows.Next() {
		var i GetScoresByIDRow
		if err := rows.Scan(
			&i.Scoreid,
			&i.Endid,
			&i.Arrownumber,
			&i.Score,
			&i.Endid_2,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
			&i.Rangeid_2,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStagedEnds = `-- name: GetStagedEnds :many
SELECT endid, en.rangeid, archeryaustraliaid, finalscore, staged, ra.rangeid, ra.roundid, distance, targetsize, r.roundid, r.eventid, class, division, gender, e.eventid, name, date
FROM End en
JOIN ` + "`" + `Range` + "`" + ` ra ON ra.RangeID = en.RangeID
JOIN ` + "`" + `Round` + "`" + ` r ON r.RoundID = ra.RoundID
JOIN Event e ON e.EventID = r.EventID
WHERE en.Staged = TRUE
`

type GetStagedEndsRow struct {
	Endid              int32         `json:"endid"`
	Rangeid            int32         `json:"rangeid"`
	Archeryaustraliaid string        `json:"archeryaustraliaid"`
	Finalscore         int32         `json:"finalscore"`
	Staged             bool          `json:"staged"`
	Rangeid_2          int32         `json:"rangeid_2"`
	Roundid            int32         `json:"roundid"`
	Distance           int32         `json:"distance"`
	Targetsize         int32         `json:"targetsize"`
	Roundid_2          int32         `json:"roundid_2"`
	Eventid            int32         `json:"eventid"`
	Class              RoundClass    `json:"class"`
	Division           RoundDivision `json:"division"`
	Gender             RoundGender   `json:"gender"`
	Eventid_2          int32         `json:"eventid_2"`
	Name               string        `json:"name"`
	Date               time.Time     `json:"date"`
}

func (q *Queries) GetStagedEnds(ctx context.Context) ([]GetStagedEndsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStagedEnds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStagedEndsRow
	for rows.Next() {
		var i GetStagedEndsRow
		if err := rows.Scan(
			&i.Endid,
			&i.Rangeid,
			&i.Archeryaustraliaid,
			&i.Finalscore,
			&i.Staged,
			&i.Rangeid_2,
			&i.Roundid,
			&i.Distance,
			&i.Targetsize,
			&i.Roundid_2,
			&i.Eventid,
			&i.Class,
			&i.Division,
			&i.Gender,
			&i.Eventid_2,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stageEnd = `-- name: StageEnd :exec
UPDATE End
SET Staged = FALSE
WHERE EndID = ?
`

func (q *Queries) StageEnd(ctx context.Context, endid int32) error {
	_, err := q.db.ExecContext(ctx, stageEnd, endid)
	return err
}
